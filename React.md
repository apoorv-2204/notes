l
#### ReactBasics

###### section1
- Benefits of putting function under component function is that they have acces to component state and props
- Custom FC must be in pascal case, as built in components starts with lowercase. 
- FC Returns render-able content or string, number boolean,null,jsx or array of this values.
- Built in components are rendered as DOM nodes
- jsx not supported by browser. index.jsx entry point of react
- react traverses component tree until it has only  built in components left.
- JSX allows you to define the target UI / HTML code right inside your JavaScript code
- React does not derive or generate any HTML file instead it render to root div.
###### section2
- Using src in images with abosulute/relative path might get lost during deployment or bundling
- depending upon build tool `import "./index.css"`  and `import a.png from "./assets/a.png"`.(auto generated by tool)
- 
- atom molecules and organisms
- By "importing" the image, a production-safe path gets generated under the hood.
  set img src equal to the path generated via an import statement.
  - u assign a dynamic value to an HTML element attribute via { } curly braces.syntax can be used to output dynamic values / **JavaScript expressions in JSX**
  - Props are essentially custom attributes that can be set on components.( reusability of React components)
  - React automatically passes a props object as the first argument to the receiving component
  -   `...props` syntax is used to collect all the properties passed to `MyComponent` into a single `props` object. In this case, it's not necessary to explicitly list each prop name in the function parameter; the spread operator takes care of that.
    
```jsx
    function MyComponent({...props}) {
	  return <p>{props.priority}</p>;
	}
  <MyComponent priority={5} />;
```



Re-render: Whenever the state of a component changes, react re-evaluates the component to which the state belongs. "Re-evaluation", "Render-Cycle" means component function is executed again.

Side Effects: ref: [[side effects]]

### UseEffect Hook

#hook #side-effect

	Extracts the side effects out of React Component,and preventing infinite loops and bugs.use effect is executed after returning jsx\. Use effect is executed after return jsx.

- It does not return a value, though accept a function and optional dependency array.
- `useEffect(anonoymous-function, args)
- Second argument  is to control the frequency with which the use effect function will be executed.
- Without any args `useEffect(fn)` 
	-  The anonymous function is executed for every [[FC]] execution or for every render cycle(after every component re-evaluation)
- With an empty array `useEffect(fn, [])`
	-  The function is executed only once, when the component is rendered for the first time. Only on the first render or the first [[FC]] execution.(react default behaviour)
- With an dependency array `useEffect(fn,[variable,fn]`
	- Change in value of Any dependency specified in the array, will cause the lambda [[fn]] to be executed again.

The array passed to `useEffect` should contain all variables , constants, functions , or the function used inside the `useEffect`, as a dependency. As it is logical that whatever object whose value is used inside the `useEffect` function, on change of the value the `useEffect` function must be re-evaluated, Since the value are not same any more.

##### Adding variables to use effect dependency array
 - Internal Values: must be omitted , as these value are defined and used inside of use effect function.(it does not belong/or defined in the component function to which effect belongs)
- External Values: must be omitted, as they are not defined inside component and generally not susceptible  to change.
- State updating: must be omitted, But react guarantees that those functions will never change or be recreated. (The first render cycle creates a state and state updating function, not the subsequent render cycle.)
- In remaining cases, must be added. 
- Omitting variables can result in unexpected use-effect executions, such as an effect running too frequently or not enough.

Always add non external dependencies  to dependencies array regardless of variable /object / function

```
mainAppRenderCount 1
 take1 1
before url change handler
beforeuseEffectr
post useEffectr
end of jsx
use effect execution 1
urlchangeHandler 
take1 2 
before url change handler 
beforeuseEffectr 
post useEffectr  
end of jsx 
use effect execution 2 
isValidUrl 
Object { products: (30) […], total: 100, skip: 0, limit: 30 }
fetchInfo 
take1 3  
before url change handler  
beforeuseEffectr 
post useEffectr 
end of jsx
```

**Multiple Use Effect** : use effect functions can be split by dependencies. one side effect depending upon state a and another effect depending upon state b.

**Function As Dependencies**: Whenever React.FC  is executed, Function and variables defined inside of React.FC are redefined in memory, hence for reactive components its change in state.(except var&function from react hooks.). Hence its possible that multiple functions based on same function definition exist in memory, due to multiple render of same React.FC. Function in React.FC are re-defined on very render. Functions are just objects and can change if their surrounding code executes again.


**Avoiding Unnecessary UseEffect execution using useCallback hook**
React.FC can contain multiple states, change in either one can cause re-render, Functions inside React.FC gets redefined  whenever there is a change in state A, its fine if those functions interact with State A but its not wise that internal functions that manipulate state B to be redefined either. or vice-versa. Internal function exist to allow easier access to the component state. 

useCallback hooks, provides a way to redefine a function again, only if there is change in certain objects/states.It takes two argument a function and dependencies array.
It does not execute the received function, it returns latest saved function object.

It ensures that a function is only recreated if one of the specified dependencies has changed.

**Asynchronous Code and Use Effect**: function given as an argument to useEffect should not be asynchronous or return a promise. It can be mitigated by using promise .then & .catch inside of useEffect Function or A async function can be defined inside of useEffect function as async and invoking it inside the useEffect Function. 



### React Optimisation techniques

***Issue***: Any component function invocation also influences its descendent components,  Descendent components may or may not have state. Entire Component tree is re-rendered if the parent state changes,(even though those parent state changes don't affect the child components).hence multiple components are affected from single state change 

Whenever a component function is executed React evaluates whether or not the rendered ui/dom of loaded page to be updated. Since React FC can trigger and updates several times. Removing and adding or updating DOM elements is quit performance intensive task especially when done in high frequency.'

React does not  throw away the current DOM and replace it with new DOM , due to a component function was re-rendered/updated. React first checks whether the updated is required and if where, only those parts of DOM are updated/changed.


**Virtual DOM**:
React does not use real dom to determine whether any user interface updates are needed. React constructs and maintains its own DOM internally in memory called virtual DOM. IN memory representation of the rendered DOM in browser- Virtual DOM.
DOM Tree vs jsx code returned virtual tree for next cycle.

React has its own version of html tags known as **ReactNode**.React uses virtual dom because comparing the virtual DOM to the expected virtual dom/ui is less performance intensive than reaching out to real dom.

*react-dom* package compares the current dom structure to the  structure implemented by the jsx code. 

+ Comparing real dom & dom to be rendered by the react is performance intensive, since multiple read operation have to be sent to real dom.(for several components)
+ TO avoid it react build its own virtual dom (b/w render cycle) and compares them. it is less intensive then comparison b/w real dom.
+ Still comparing virtual dom is CPU intensive task.(due to nb of freq)
+ If lot of components are there changes can trigger multiple dom comparison. And those comparison some times unnecessary  

>React provides various optimisation technique to avoid unnecessary comparison/-re-renders

`State Batching, Memo, useMemo(), useCallback(), lazy(), Suspense & fallback.` 

*__State Batching__ || Multiple sequential state updates*:
Unnecessary comparison are performed in multiple sequential state updates. **Number of useState() in a component = nb of re-render for React.FC** Since each state update causes re-evaluation/re-renders/virtual dom comparisons it can be avoided by performing states updates together called state batching. React undertakes state batches when multiple state updates are initiated from the same place in the code.


ex: A Component have an increment counter and a show Counter state(number & boolean) On state update, counter is incremented and show counter is set to not of old value.Using profiler we see that component re-render only once , if strict mode is turned off.In 

>**IN strict mode react ,will execute components function more other than it normally would.The `<React.StrictMode>` does not render any visually component, but it does some checks for legacy and unsafe code( features that are going to be removed in the future updated).
> It also causes the react to execute component function twice. Also unmounts and re-mounts every component it mounts for the first time to ensure state management and side effect are handled in consistent and correct way.Double component function execution are not performed in production  **

**Memo**: To avoid unnecessary child component evaluation. Its possible that change in parent component state does not translate to child component re-evaluation, the might not depend on parent components at all. To avoid the re-render if component props does not change we need to wrap in memo function before using. It checks and compare current to last time props ,if props were equal then React.FC is not executed again.
memo( ) also takes an optional second argument ,which is anonymous function which get two parameters `prevProps` and `nextProps`  to allow custom logic for comparison for nested props,etc. return true if component need to be re-evaluated false if not.By default it compares all the props for inequality.

Best-practices: Cant use memo everywhere , because use of memo also come at a cost, may not yield measurable benefit. But a good practices will be to wrap the components which are top of component tree prevent render of nested components also.
example: if there is error reporting component and other value input and reporting component like `input` and `<p>` and by lifting state up for both of them in third React.FC, change in input will also cause the error component to be re-render. it can be wrapped under memo function, which checks props whether they changes or not since no error it wont render again.

**Avoiding re-doing CPU intensive tasks** , **useMemo()** :
Its possible to have a situation where To avoid a CPU intensive component to be re-executed again because some prop changed.In this situation memo function wont prevent its re-execution.But the prop changed might not be involved with CPU intensive task , hence it is required to be re-calculated.

useMemo() hook is used to control partial code execution inside of React.FC. It is used
to wrap CPU intensive task , and receives a list of dependencies on its change the work need to re-calculated 


>useEffect() is used for side effects and executed , when executed of component function is completed.
>
>useMemo() is used for CPU intensive task, its is executed at the same time when rest of code of React.FC is being executed.
>
>useCallback() is used to avoid unnecessary function re-creation/re-definition.


example: A React.FC accepts two props max item to show and list of items,if change in umber of max item show changes , its not required to sort again the list of items. 
hence sorting can wrapped by useMemo with max-items dependency 

> useCallback() can be used in conjunction with useMemo(). If intensive task is wrapped with useMemo(), & uses function as dependency. useCallback can be used to ensure that this  dependent function is not recreated unnecessary.
> ex: value and function as prop. Func invoked inside useMemo function with that function as dependency. And that Func can be wrapped in use callback Hook 



**Dodging unnecessary code download**: 

For small bundle size: 1) write short code 2) less third part libraries, prefer writing that portion by yourself. 3) code splitting.


`lazy()`:  It is used to load component code conditionally, instead of loading it upfront.
If a component uses third party lib, there is lot of code to be loaded upfront, instead of that, Component should be rendered conditionally with lazy import ensuring, component using third party dependencies has not to be loaded upfront, and loading its lib only when required.

The component using large size third party should be imported via lazy.And it is also required to wrap the conditional JSX code where the dynamically imported component is used, with another component provided by react `<Suspense>`, with mandatory prop `fallback`. Fallback component is rendered until the dynamically loaded content is available. `lazy` allows the overall js code  being split up into multiple bundles.Not a good idea to used lazy on all components, rather conditionally loaded components.

```
const HeavyComponent= lazy(()=> import('component using third partylib'));
<Suspense fallback={<p> fetching.. </p> } >
	showHeavyComponent && <HeavyComponent />
</Suspense>
```

React debug tools Profiler and components:
Components page is used to study structure of currently rendered component tree.

Profiler: it allows to record component render cycles.It shows list of bars indicating the number of component re-evaluations. For the selected evaluation cycle a list of affected component is presented 


### Complex State Management
### UseContext Api Hook
 


###  React.ReactNode vs JSX.Element vs React.ReactElement 
https://www.totaltypescript.com/jsx-element-vs-react-reactnode


#### Why react use effect executed twice On first render cycle?(since react 18)
https://byby.dev/useeffect-run-twice